/*
	MIT License

	Copyright (c) 2021 Scribe Language Repositories

	Permission is hereby granted, free of charge, to any person obtaining a
	copy of this software and associated documentation files (the "Software"), to
	deal in the Software without restriction, including without limitation the
	rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	sell copies of the Software, and to permit persons to whom the Software is
	furnished to do so.
*/

#include "Parser/Stmts.hpp"

namespace sc
{
///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtBlock ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtBlock::clone(Context &ctx)
{
	std::vector<Stmt *> newstmts;
	for(auto &stmt : stmts) {
		newstmts.push_back(stmt->clone(ctx));
	}
	return StmtBlock::create(ctx, getLoc(), newstmts, is_top);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtType /////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtType::clone(Context &ctx)
{
	return StmtType::create(ctx, getLoc(), ptr, info, expr->clone(ctx));
}

///////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// StmtSimple /////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtSimple::clone(Context &ctx)
{
	StmtSimple *newsim	  = StmtSimple::create(ctx, getLoc(), val);
	newsim->self		  = self ? self->clone(ctx) : nullptr;
	newsim->applied_module_id = applied_module_id;
	return newsim;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////// StmtFnCallInfo ///////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtFnCallInfo::clone(Context &ctx)
{
	std::vector<Stmt *> newargs;
	for(auto &a : args) {
		newargs.push_back(a->clone(ctx));
	}
	return StmtFnCallInfo::create(ctx, getLoc(), newargs);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtExpr /////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtExpr::clone(Context &ctx)
{
	StmtExpr *newexpr =
	StmtExpr::create(ctx, getLoc(), commas, lhs ? lhs->clone(ctx) : nullptr, oper,
			 rhs ? rhs->clone(ctx) : nullptr, is_intrinsic_call);
	newexpr->or_blk	    = or_blk ? as<StmtBlock>(or_blk->clone(ctx)) : nullptr;
	newexpr->or_blk_var = or_blk_var;
	newexpr->calledfn   = calledfn;
	return newexpr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtVar //////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtVar::clone(Context &ctx)
{
	StmtType *newvtype = vtype ? as<StmtType>(vtype->clone(ctx)) : nullptr;
	Stmt *newvval	   = vval ? vval->clone(ctx) : nullptr;
	StmtVar *res =
	StmtVar::create(ctx, getLoc(), name, newvtype, newvval, is_in, is_comptime, is_global);
	res->setAppliedModuleID(applied_module_id);
	return res;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtFnSig ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtFnSig::clone(Context &ctx)
{
	std::vector<StmtVar *> newargs;
	for(auto &a : args) {
		newargs.push_back(as<StmtVar>(a->clone(ctx)));
	}
	StmtType *newrettype = rettype ? as<StmtType>(rettype->clone(ctx)) : nullptr;
	return StmtFnSig::create(ctx, getLoc(), newargs, newrettype, scope, has_variadic);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtFnDef ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtFnDef::clone(Context &ctx)
{
	StmtFnSig *newsig = as<StmtFnSig>(sig->clone(ctx));
	StmtBlock *newblk = blk ? as<StmtBlock>(blk->clone(ctx)) : nullptr;
	return StmtFnDef::create(ctx, getLoc(), newsig, newblk);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// StmtHeader /////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtHeader::clone(Context &ctx)
{
	return StmtHeader::create(ctx, getLoc(), names, flags);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtLib //////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtLib::clone(Context &ctx)
{
	return StmtLib::create(ctx, getLoc(), flags);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// StmtExtern /////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtExtern::clone(Context &ctx)
{
	StmtHeader *newheaders = headers ? as<StmtHeader>(headers->clone(ctx)) : nullptr;
	StmtLib *newlibs       = libs ? as<StmtLib>(libs->clone(ctx)) : nullptr;
	StmtFnSig *newsig      = as<StmtFnSig>(sig->clone(ctx));
	return StmtExtern::create(ctx, getLoc(), fname, newheaders, newlibs, newsig);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////// StmtEnum //////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtEnum::clone(Context &ctx)
{
	return StmtEnum::create(ctx, getLoc(), items);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////// StmtStruct //////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtStruct::clone(Context &ctx)
{
	std::vector<StmtVar *> newfields;
	for(auto &f : fields) {
		newfields.push_back(as<StmtVar>(f->clone(ctx)));
	}
	return StmtStruct::create(ctx, getLoc(), newfields);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////// StmtVarDecl /////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtVarDecl::clone(Context &ctx)
{
	std::vector<StmtVar *> newdecls;
	for(auto &d : decls) {
		newdecls.push_back(as<StmtVar>(d->clone(ctx)));
	}
	return StmtVarDecl::create(ctx, getLoc(), newdecls);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtCond /////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtCond::clone(Context &ctx)
{
	std::vector<Conditional> newconds;
	for(auto &c : conds) {
		Stmt *newcond	  = c.getCond() ? c.getCond()->clone(ctx) : nullptr;
		StmtBlock *newblk = as<StmtBlock>(c.getBlk()->clone(ctx));
		newconds.push_back(Conditional(newcond, newblk));
	}
	return StmtCond::create(ctx, getLoc(), newconds, is_inline);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// StmtForIn //////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtForIn::clone(Context &ctx)
{
	StmtBlock *newblk = blk ? as<StmtBlock>(blk->clone(ctx)) : nullptr;
	return StmtForIn::create(ctx, getLoc(), iter, in->clone(ctx), newblk);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtFor //////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtFor::clone(Context &ctx)
{
	Stmt *newinit	  = init ? init->clone(ctx) : nullptr;
	Stmt *newcond	  = cond ? cond->clone(ctx) : nullptr;
	Stmt *newincr	  = incr ? incr->clone(ctx) : nullptr;
	StmtBlock *newblk = blk ? as<StmtBlock>(blk->clone(ctx)) : nullptr;
	return StmtFor::create(ctx, getLoc(), newinit, newcond, newincr, newblk, is_inline);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtWhile ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtWhile::clone(Context &ctx)
{
	Stmt *newcond	  = cond ? cond->clone(ctx) : nullptr;
	StmtBlock *newblk = blk ? as<StmtBlock>(blk->clone(ctx)) : nullptr;
	return StmtWhile::create(ctx, getLoc(), newcond, newblk);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtRet //////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtRet::clone(Context &ctx)
{
	Stmt *newval = val ? val->clone(ctx) : nullptr;
	StmtRet *res = StmtRet::create(ctx, getLoc(), newval);
	res->setFnBlk(fnblk);
	return res;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// StmtContinue ///////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtContinue::clone(Context &ctx)
{
	return StmtContinue::create(ctx, getLoc());
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtBreak ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtBreak::clone(Context &ctx)
{
	return StmtBreak::create(ctx, getLoc());
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtDefer ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtDefer::clone(Context &ctx)
{
	return StmtDefer::create(ctx, getLoc(), val->clone(ctx));
}

} // namespace sc