/*
	MIT License

	Copyright (c) 2021 Scribe Language Repositories

	Permission is hereby granted, free of charge, to any person obtaining a
	copy of this software and associated documentation files (the "Software"), to
	deal in the Software without restriction, including without limitation the
	rights to use, copy, modify, merge, publish, distribute, sublicense, and/or
	sell copies of the Software, and to permit persons to whom the Software is
	furnished to do so.
*/

#include "Parser/Stmts.hpp"

namespace sc
{
///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtBlock ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtBlock::clone()
{
	std::vector<Stmt *> newstmts;
	for(auto &stmt : stmts) {
		newstmts.push_back(stmt->clone());
	}
	return new StmtBlock(getLoc(), newstmts, is_top);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtType /////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtType::clone()
{
	return new StmtType(getLoc(), ptr, info, expr->clone());
}

///////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// StmtSimple /////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtSimple::clone()
{
	StmtSimple *newsim	  = new StmtSimple(getLoc(), val);
	newsim->self		  = self ? self->clone() : nullptr;
	newsim->applied_module_id = applied_module_id;
	return newsim;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////// StmtFnCallInfo ///////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtFnCallInfo::clone()
{
	std::vector<Stmt *> newargs;
	for(auto &a : args) {
		newargs.push_back(a->clone());
	}
	return new StmtFnCallInfo(getLoc(), newargs);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtExpr /////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtExpr::clone()
{
	StmtExpr *newexpr   = new StmtExpr(getLoc(), commas, lhs ? lhs->clone() : nullptr, oper,
					   rhs ? rhs->clone() : nullptr, is_intrinsic_call);
	newexpr->or_blk	    = or_blk ? as<StmtBlock>(or_blk->clone()) : nullptr;
	newexpr->or_blk_var = or_blk_var;
	newexpr->calledfn   = calledfn;
	return newexpr;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtVar //////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtVar::clone()
{
	StmtType *newvtype = vtype ? as<StmtType>(vtype->clone()) : nullptr;
	Stmt *newvval	   = vval ? vval->clone() : nullptr;
	StmtVar *res =
	new StmtVar(getLoc(), name, newvtype, newvval, is_in, is_comptime, is_global);
	res->setAppliedModuleID(applied_module_id);
	return res;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtFnSig ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtFnSig::clone()
{
	std::vector<StmtVar *> newargs;
	for(auto &a : args) {
		newargs.push_back(as<StmtVar>(a->clone()));
	}
	StmtType *newrettype = rettype ? as<StmtType>(rettype->clone()) : nullptr;
	return new StmtFnSig(getLoc(), newargs, newrettype, scope, has_variadic);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtFnDef ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtFnDef::clone()
{
	StmtFnSig *newsig = as<StmtFnSig>(sig->clone());
	StmtBlock *newblk = blk ? as<StmtBlock>(blk->clone()) : nullptr;
	return new StmtFnDef(getLoc(), newsig, newblk);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// StmtHeader /////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtHeader::clone()
{
	return new StmtHeader(getLoc(), names, flags);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtLib //////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtLib::clone()
{
	return new StmtLib(getLoc(), flags);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// StmtExtern /////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtExtern::clone()
{
	StmtHeader *newheaders = headers ? as<StmtHeader>(headers->clone()) : nullptr;
	StmtLib *newlibs       = libs ? as<StmtLib>(libs->clone()) : nullptr;
	StmtFnSig *newsig      = as<StmtFnSig>(sig->clone());
	return new StmtExtern(getLoc(), fname, newheaders, newlibs, newsig);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
/////////////////////////////////////////// StmtEnum //////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtEnum::clone()
{
	return new StmtEnum(getLoc(), items);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////// StmtStruct //////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtStruct::clone()
{
	std::vector<StmtVar *> newfields;
	for(auto &f : fields) {
		newfields.push_back(as<StmtVar>(f->clone()));
	}
	return new StmtStruct(getLoc(), newfields);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
///////////////////////////////////////// StmtVarDecl /////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtVarDecl::clone()
{
	std::vector<StmtVar *> newdecls;
	for(auto &d : decls) {
		newdecls.push_back(as<StmtVar>(d->clone()));
	}
	return new StmtVarDecl(getLoc(), newdecls);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtCond /////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtCond::clone()
{
	std::vector<Conditional> newconds;
	for(auto &c : conds) {
		Stmt *newcond	  = c.getCond() ? c.getCond()->clone() : nullptr;
		StmtBlock *newblk = as<StmtBlock>(c.getBlk()->clone());
		newconds.push_back(Conditional(newcond, newblk));
	}
	return new StmtCond(getLoc(), newconds, is_inline);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// StmtForIn //////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtForIn::clone()
{
	StmtBlock *newblk = blk ? as<StmtBlock>(blk->clone()) : nullptr;
	return new StmtForIn(getLoc(), iter, in->clone(), newblk);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtFor //////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtFor::clone()
{
	Stmt *newinit	  = init ? init->clone() : nullptr;
	Stmt *newcond	  = cond ? cond->clone() : nullptr;
	Stmt *newincr	  = incr ? incr->clone() : nullptr;
	StmtBlock *newblk = blk ? as<StmtBlock>(blk->clone()) : nullptr;
	return new StmtFor(getLoc(), newinit, newcond, newincr, newblk, is_inline);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtWhile ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtWhile::clone()
{
	Stmt *newcond	  = cond ? cond->clone() : nullptr;
	StmtBlock *newblk = blk ? as<StmtBlock>(blk->clone()) : nullptr;
	return new StmtWhile(getLoc(), newcond, newblk);
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtRet //////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtRet::clone()
{
	Stmt *newval = val ? val->clone() : nullptr;
	StmtRet *res = new StmtRet(getLoc(), newval);
	res->setFnBlk(fnblk);
	return res;
}

///////////////////////////////////////////////////////////////////////////////////////////////////
////////////////////////////////////////// StmtContinue ///////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtContinue::clone()
{
	return new StmtContinue(getLoc());
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtBreak ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtBreak::clone()
{
	return new StmtBreak(getLoc());
}

///////////////////////////////////////////////////////////////////////////////////////////////////
//////////////////////////////////////////// StmtDefer ////////////////////////////////////////////
///////////////////////////////////////////////////////////////////////////////////////////////////

Stmt *StmtDefer::clone()
{
	return new StmtDefer(getLoc(), val->clone());
}

} // namespace sc